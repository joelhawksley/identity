<?xml version="1.0" encoding="utf-8"?>
<html>
  <head>
    <meta charset="utf-8"/>
  </head>
  <body>
    <ul id="_Fx_2vap">
      <li id="3C">
        <p>ActionView template signatures</p>
        <ul>
          <li id="FWV">
            <p>Hey Felipe! I chatted with some folks from Rails core at RailsConf about adding something to ActionView core that could support this functionality, sidestepping ViewComponent entirely.</p>
          </li>
          <li id="SWf">
            <p>:wave: hello folks! Joel from GitHub here. After a couple of years of working on ViewComponent I have an idea for how we could incorporate some of what we've learned on the proejct back into Rails core.</p>
          </li>
          <li id="Fq">
            <p>Problem statement</p>
            <ul>
              <li id="Gt">
                <p>Performance</p>
                <ul>
                  <li id="Cl">
                    <p>AV templates are compiled for each unique combination of locals at runtime, for each process, reset every deploy. GitHub currently employs a precompiler and linter TODO ADD LINKS to get around this limitation, but it requires limiting `render` calls to fully qualified paths. (pull_request/show vs. show)</p>
                  </li>
                </ul>
              </li>
              <li id="5v">
                <p>Implementation</p>
                <ul>
                  <li id="3M">
                    <p>Default setting in ERB head matter</p>
                  </li>
                </ul>
              </li>
              <li id="L5">
                <p>Indirection</p>
                <ul>
                  <li id="Sd">
                    <p>Calling render(:show) has a different result depending on where the template is rendered</p>
                  </li>
                  <li id="Sik">
                    <p>Compilted ActionView templates are currently a hidden API, making them difficult to reason about and test directly</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li id="Kf">
            <p>Proposed solution</p>
            <ul>
              <li id="Y3">
                <p>In chatting with core members @tenderlove @jhawthorn and @_byroot at RailsConf, we came up with the idea of allowing for optional template signatures using a magic comment, something along the lines of: # @arguments (foo, bar:, baz: true). We would then compile these arguments as the method signature for the template.</p>
              </li>
              <li id="HT">
                <p>Performance</p>
                <ul>
                  <li id="P2">
                    <p>Doing so would allow us to precompile templates at application boot time, instead of at runtime in a mutex TODO ADD LINK</p>
                  </li>
                </ul>
              </li>
              <li id="pbB">
                <p>Indirection</p>
                <ul>
                  <li id="R_L">
                    <p>With a known set of arguments, we can compile templates into a predictable format, much like route helpers.</p>
                  </li>
                  <li id="OX9">
                    <p>I think we could avoid this for the first iteration of this approach.</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li id="EXv">
            <p>Example</p>
            <ul>
              <li id="fiX">
                <p>TODO use YARD syntax? Sorbet syntax?</p>
              </li>
              <li id="JNI">
                <p>Before</p>
                <ul>
                  <li id="09d">
                    <p>&lt;%# issues/_card.html.erb %&gt;</p>
                  </li>
                  <li id="eFG">
                    <p>&lt;% title = local_assigns[:title] || "Default title" %&gt;</p>
                  </li>
                  <li id="dMN">
                    <p>&lt;% comment_count = local_assigns[:comment_count] || 0 %&gt;</p>
                  </li>
                  <li id="D4S">
                    <p>&lt;h2&gt;&lt;%= title %&gt;&lt;/h2&gt;</p>
                  </li>
                  <li id="Rt5">
                    <p>&lt;span class="comment-count"&gt;&lt;%= comment_count %&gt;&lt;/span&gt;</p>
                  </li>
                </ul>
              </li>
              <li id="Xvh">
                <p>After</p>
                <ul>
                  <li id="yxm">
                    <p>&lt;%# issues/_card.html.erb %&gt;</p>
                  </li>
                  <li id="P2N">
                    <p>&lt;%# @params title: "Default title", comment_count: 0 %&gt;</p>
                  </li>
                  <li id="gzp">
                    <p>&lt;h2&gt;&lt;%= title %&gt;&lt;/h2&gt;</p>
                  </li>
                  <li id="oja">
                    <p>&lt;span class="comment-count"&gt;&lt;%= comment_count %&gt;&lt;/span&gt;</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li id="j9u">
            <p>Alternatives considered</p>
            <ul>
              <li id="i9K">
                <p>Compiling templates to one object per template, using object initializer for arguments</p>
                <ul>
                  <li id="K9Z">
                    <p>This is more or less what we've built with ViewComponent at GitHub. It's worked quite well for us, but wrapping a template in an object has its downsides when it comes to object allocations in heavy usage and we've had issues with form helpers.</p>
                  </li>
                </ul>
              </li>
              <li id="brp">
                <p>Implicit signature compilation</p>
                <ul>
                  <li id="JGC">
                    <p>We could, in theory, generate the signature for a template by traversing its AST or another form of static analysis. This has proven difficult in our experience and still does not allow one to set defaults for arguments or to require arguments.</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </body>
</html>
